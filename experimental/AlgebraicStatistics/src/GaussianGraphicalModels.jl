import Oscar.gens


struct GaussianRing
    ring::Ring
    gens::Dict
    covariance_matrix
end


Base.show(io::IO, R::GaussianRing) = print("Multivariate polynomial ring over "*string(base_ring(R.ring))*" in "*string(ngens(R.ring))*" variables", "\n", chop(string(gens(R.ring)), head = 16, tail = 1))


# todo
function ring(R::GaussianRing)

    R.ring
end


# todo
function gens(R::GaussianRing)

    R.gens
end


# todo 
function covariance_matrix(R::GaussianRing)

    R.covariance_matrix
end


# todo
function var_index(x)

    str = string(x)
    index = "["*split(str, "[")[2]

    eval(Meta.parse(index))
end



# creates a ring with variables corresponding to the entries of a (n x n) symmetric matrix
function gaussian_ring(n::Int64, s_var_name::String="s")::GaussianRing

    S, s = polynomial_ring(QQ, reduce(vcat, [[s_var_name*string([i,j]) for j in i:n] for i in 1:n]))

    s = Dict([(Tuple(var_index(x)), x) for x in s])

    cov_matrix = matrix([[i < j ? s[i,j] : s[j,i] for j in 1:n] for i in 1:n])

    GaussianRing(S, s, cov_matrix)
end



# creates a ring with variables corresponding to the entries of a covariance matrix
# and the edge weights of G
function graphical_model(G::Graph{Directed}, S::GaussianRing, l_var_name::String="l")::GraphicalModel

    R, l = polynomial_ring(QQ, ["l"*string([src(e), dst(e)]) for e in edges(G)])

    l = Dict([(Tuple(var_index(x)), x) for x in l])

    GraphicalModel(G, S, R, l)
end



# todo
function graphical_model(G::Graph{Undirected}, S::GaussianRing, k_var_name::String="k")

    

    #todo
end



# creates matrix of parameters which correspond to the directed edges of a digraph
function directed_edges_matrix(M::GraphicalModel{Directed, GaussianRing})

    #todo
end



# creates matrix of parameters which correspond to the directed edges of a digraph
# creates the parameterization of the model as a ring map
function parameterization(M::GraphicalModel{Directed, GaussianRing})


    # make the parameterization with the directed edges matrix
end



# todo
function parameterization(M::GraphicalModel{Undirected, GaussianRing})

    # make parameterization with inverse
end



# computes the ideal generated by all trek separations
function trek_ideal(M::GraphicalModel{Directed, GaussianRing})

end



# computes the ideal generated by all trek separations
function trek_ideal(M::GraphicalModel{Directed, GaussianRing})

end